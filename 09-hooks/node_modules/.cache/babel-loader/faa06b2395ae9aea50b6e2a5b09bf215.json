{"ast":null,"code":"var _jsxFileName = \"/Users/JamesNa/scripts/Web Dev/React/09-hooks/src/components/Counter.js\";\nimport React, { useState } from 'react'; // we can write this function as a fat arrow function like this\n// but cant default export it\n// const Counter = props => {\n// }\n\nexport default function Counter(props) {\n  // the useStatefunction is a hook\n  // All hooks (including custom) are prefixed 'use' \n  // useState accepts a value representing the initial state\n  // useState returns an array comprising two elements:\n  // We are assigning values in the array \n  // counter is the items state (in this case a number called counter)\n  // setCounter is a setter function for updating the state\n  // just like setState the setter has two implementations\n  //  One the accpets a new value, used where the new value is not dependent on the old\n  // Two, one that accepts a function, used where the new value IS dependent on the old\n  const [counter, setCounter] = useState(0); // We could declare the function here and call it from the jsx\n  // But its easier to write it inline with a fat arrow\n  // const handleButtonClick = event => setCounter(counter + 1);\n\n  return (\n    /*#__PURE__*/\n    // the empty tags are a REACT fragmnet\n    // saves us from litering the HTML with unnecessary divs\n    React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"p\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 17\n      }\n    }, \"Counter: \", counter), /*#__PURE__*/React.createElement(\"button\", {\n      onClick: () => setCounter(counter + 1),\n      className: \"btn btn-primary\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 35,\n        columnNumber: 17\n      }\n    }, \"Increment Counter\"))\n  );\n}","map":{"version":3,"sources":["/Users/JamesNa/scripts/Web Dev/React/09-hooks/src/components/Counter.js"],"names":["React","useState","Counter","props","counter","setCounter"],"mappings":";AAAA,OAAOA,KAAP,IAAeC,QAAf,QAA8B,OAA9B,C,CAEA;AACA;AAEA;AAEA;;AAGA,eAAe,SAASC,OAAT,CAAiBC,KAAjB,EAAwB;AACnC;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA,QAAM,CAACC,OAAD,EAAUC,UAAV,IAAwBJ,QAAQ,CAAC,CAAD,CAAtC,CAbmC,CAenC;AACA;AACA;;AAEI;AAAA;AACI;AACA;AACA,2DACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAaG,OAAb,CADJ,eAEI;AAAQ,MAAA,OAAO,EAAE,MAAMC,UAAU,CAACD,OAAO,GAAG,CAAX,CAAjC;AAAgD,MAAA,SAAS,EAAC,iBAA1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BAFJ;AAHJ;AAQP","sourcesContent":["import React, {useState} from 'react';\n\n// we can write this function as a fat arrow function like this\n// but cant default export it\n\n// const Counter = props => {\n\n// }\n\n\nexport default function Counter(props) {\n    // the useStatefunction is a hook\n    // All hooks (including custom) are prefixed 'use' \n    // useState accepts a value representing the initial state\n    // useState returns an array comprising two elements:\n\n    // We are assigning values in the array \n    // counter is the items state (in this case a number called counter)\n    // setCounter is a setter function for updating the state\n\n    // just like setState the setter has two implementations\n    //  One the accpets a new value, used where the new value is not dependent on the old\n    // Two, one that accepts a function, used where the new value IS dependent on the old\n    const [counter, setCounter] = useState(0);\n\n    // We could declare the function here and call it from the jsx\n    // But its easier to write it inline with a fat arrow\n    // const handleButtonClick = event => setCounter(counter + 1);\n\n        return (\n            // the empty tags are a REACT fragmnet\n            // saves us from litering the HTML with unnecessary divs\n            <>\n                <p>Counter: {counter}</p>\n                <button onClick={() => setCounter(counter + 1)} className='btn btn-primary'>Increment Counter</button>\n            </>\n        );\n}"]},"metadata":{},"sourceType":"module"}